package toolbox

// OmitBy returns a map whose elements the predicate function returns falsey for, from in-map.
func OmitBy[K comparable, V any](in map[K]V, predicate func(key K, value V) bool) map[K]V {
	result := make(map[K]V)
	for k, v := range in {
		if !predicate(k, v) {
			result[k] = v
		}
	}
	return result
}

// OmitByKeys returns a map exclude keys in `keys` from in-map.
func OmitByKeys[K comparable, V any](in map[K]V, keys []K) map[K]V {
	result := make(map[K]V)
	keysSet := CollectionToSet(keys)
	for k, v := range in {
		if _, ok := keysSet[k]; !ok {
			result[k] = v
		}
	}
	return result
}

// OmitByValues returns a map exclude values in `values` from in-map.
func OmitByValues[K comparable, V comparable](in map[K]V, values []V) map[K]V {
	result := make(map[K]V)
	valuesSet := CollectionToSet(values)
	for k, v := range in {
		if _, ok := valuesSet[v]; !ok {
			result[k] = v
		}
	}
	return result
}

// PickBy returns a map whose elements the predicate function returns truthy for, from in-map.
func PickBy[K comparable, V any](in map[K]V, predicate func(key K, value V) bool) map[K]V {
	result := make(map[K]V)
	for k, v := range in {
		if predicate(k, v) {
			result[k] = v
		}
	}
	return result
}

// PickByKeys returns a map include keys in `keys` from in-map.
func PickByKeys[K comparable, V any](in map[K]V, keys []K) map[K]V {
	result := make(map[K]V)
	keysSet := CollectionToSet(keys)
	for k, v := range in {
		if _, ok := keysSet[k]; ok {
			result[k] = v
		}
	}
	return result
}

// PickByValues returns a map include values in `values` from in-map.
func PickByValues[K comparable, V comparable](in map[K]V, values []V) map[K]V {
	result := make(map[K]V)
	valuesSet := CollectionToSet(values)
	for k, v := range in {
		if _, ok := valuesSet[v]; ok {
			result[k] = v
		}
	}
	return result
}

type Entry[K comparable, V any] struct {
	Key   K
	Value V
}

// ToEntries returns an entries of array in in-map.
func ToEntries[K comparable, V any](in map[K]V) []Entry[K, V] {
	result := make([]Entry[K, V], 0, len(in))
	for k, v := range in {
		result = append(result, Entry[K, V]{k, v})
	}
	return result
}

// FromEntries returns a map build by entries.
func FromEntries[K comparable, V any](entries []Entry[K, V]) map[K]V {
	result := make(map[K]V)
	for _, entry := range entries {
		result[entry.Key] = entry.Value
	}
	return result
}

// Invert returns a map whose keys are values in in-map, and values are keys in in-map.
func Invert[K comparable, V comparable](in map[K]V) map[V]K {
	result := make(map[V]K)
	for k, v := range in {
		result[v] = k
	}
	return result
}

// MapKeys returns a map whose keys is generated by iteratee function.
func MapKeys[K comparable, V any](in map[K]V, iteratee func(k K, v V) K) map[K]V {
	result := make(map[K]V)
	for k, v := range in {
		result[iteratee(k, v)] = v
	}
	return result
}

// MapValues returns a map whose values is generated by iteratee function.
func MapValues[K comparable, V any](in map[K]V, iteratee func(k K, v V) V) map[K]V {
	result := make(map[K]V)
	for k, v := range in {
		result[k] = iteratee(k, v)
	}
	return result
}

// MapEntries returns a map whose key-values is generated by iteratee function.
func MapEntries[K comparable, V any](in map[K]V, iteratee func(k K, v V) (K, V)) map[K]V {
	result := make(map[K]V)
	for k, v := range in {
		newK, newV := iteratee(k, v)
		result[newK] = newV
	}
	return result
}

// Merge returns a map that  contains all key-values on in-maps.
func Merge[K comparable, V any](ins ...map[K]V) map[K]V {
	result := make(map[K]V)
	for _, in := range ins {
		for k, v := range in {
			result[k] = v
		}
	}
	return result
}

// Keys return an array of keys in map.
func Keys[K comparable, V any](in map[K]V) []K {
	result := make([]K, len(in))
	for k := range in {
		result = append(result, k)
	}
	return result
}

// Values return an array of values in map.
func Values[K comparable, V any](in map[K]V) []V {
	result := make([]V, len(in))
	for _, v := range in {
		result = append(result, v)
	}
	return result
}

// ValueOr return value for key in map.
// If key not exists in map, return fallback value.
func ValueOr[K comparable, V any](in map[K]V, key K, fallback V) V {
	if v, ok := in[key]; !ok {
		return fallback
	} else {
		return v
	}
}

// MapToSlice returns an array whose elements are generated by iteratee function.
func MapToSlice[K comparable, V any, R any](in map[K]V, iteratee func(k K, v V) R) []R {
	result := make([]R, 0, len(in))
	for k, v := range in {
		result = append(result, iteratee(k, v))
	}
	return result
}
