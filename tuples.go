// Code generated by go run cmd/generate_tuples.go -output tuples.go
// DO NOT EDIT

package toolbox


type Tuple2[T1 any, T2 any] struct {
	A T1
	B T2
}

// Pack2 returns a Tuple2 instance.
func Pack2[T1 any, T2 any](a T1, b T2) Tuple2[T1, T2] {
	return Tuple2[T1, T2]{ A: a, B: b }
}

// Unpack2 returns a Tuple2's inner value.
func Unpack2[T1 any, T2 any](t2 Tuple2[T1, T2]) (T1, T2) {
	return t2.A, t2.B
}

// Zip2 returns a Tuple2 slice, whose length is max of input collections.
func Zip2[T1 any, T2 any](collection1 []T1, collection2 []T2) []Tuple2[T1, T2] {
	maxLength := Max(len(collection1), len(collection2))
	result := make([]Tuple2[T1, T2], maxLength)
	for index := 0; index < maxLength; index++ {
		a, _ := Nth(collection1, index)
		b, _ := Nth(collection2, index)
		result[index] = Tuple2[T1, T2]{ A: a, B: b }
	}
	return result
}

// Unzip2 returns 2 slices, whose elements come from Tuple2-collection.
func Unzip2[T1 any, T2 any](collection []Tuple2[T1, T2]) ([]T1, []T2) {
	length := len(collection)
	result1 := make([]T1, length)
	result2 := make([]T2, length)
	for index := 0; index < length; index++ {
		result1[index] = collection[index].A
		result2[index] = collection[index].B
	}
	return result1, result2
}

type Tuple3[T1 any, T2 any, T3 any] struct {
	A T1
	B T2
	C T3
}

// Pack3 returns a Tuple3 instance.
func Pack3[T1 any, T2 any, T3 any](a T1, b T2, c T3) Tuple3[T1, T2, T3] {
	return Tuple3[T1, T2, T3]{ A: a, B: b, C: c }
}

// Unpack3 returns a Tuple3's inner value.
func Unpack3[T1 any, T2 any, T3 any](t3 Tuple3[T1, T2, T3]) (T1, T2, T3) {
	return t3.A, t3.B, t3.C
}

// Zip3 returns a Tuple3 slice, whose length is max of input collections.
func Zip3[T1 any, T2 any, T3 any](collection1 []T1, collection2 []T2, collection3 []T3) []Tuple3[T1, T2, T3] {
	maxLength := Max(len(collection1), len(collection2), len(collection3))
	result := make([]Tuple3[T1, T2, T3], maxLength)
	for index := 0; index < maxLength; index++ {
		a, _ := Nth(collection1, index)
		b, _ := Nth(collection2, index)
		c, _ := Nth(collection3, index)
		result[index] = Tuple3[T1, T2, T3]{ A: a, B: b, C: c }
	}
	return result
}

// Unzip3 returns 3 slices, whose elements come from Tuple3-collection.
func Unzip3[T1 any, T2 any, T3 any](collection []Tuple3[T1, T2, T3]) ([]T1, []T2, []T3) {
	length := len(collection)
	result1 := make([]T1, length)
	result2 := make([]T2, length)
	result3 := make([]T3, length)
	for index := 0; index < length; index++ {
		result1[index] = collection[index].A
		result2[index] = collection[index].B
		result3[index] = collection[index].C
	}
	return result1, result2, result3
}

type Tuple4[T1 any, T2 any, T3 any, T4 any] struct {
	A T1
	B T2
	C T3
	D T4
}

// Pack4 returns a Tuple4 instance.
func Pack4[T1 any, T2 any, T3 any, T4 any](a T1, b T2, c T3, d T4) Tuple4[T1, T2, T3, T4] {
	return Tuple4[T1, T2, T3, T4]{ A: a, B: b, C: c, D: d }
}

// Unpack4 returns a Tuple4's inner value.
func Unpack4[T1 any, T2 any, T3 any, T4 any](t4 Tuple4[T1, T2, T3, T4]) (T1, T2, T3, T4) {
	return t4.A, t4.B, t4.C, t4.D
}

// Zip4 returns a Tuple4 slice, whose length is max of input collections.
func Zip4[T1 any, T2 any, T3 any, T4 any](collection1 []T1, collection2 []T2, collection3 []T3, collection4 []T4) []Tuple4[T1, T2, T3, T4] {
	maxLength := Max(len(collection1), len(collection2), len(collection3), len(collection4))
	result := make([]Tuple4[T1, T2, T3, T4], maxLength)
	for index := 0; index < maxLength; index++ {
		a, _ := Nth(collection1, index)
		b, _ := Nth(collection2, index)
		c, _ := Nth(collection3, index)
		d, _ := Nth(collection4, index)
		result[index] = Tuple4[T1, T2, T3, T4]{ A: a, B: b, C: c, D: d }
	}
	return result
}

// Unzip4 returns 4 slices, whose elements come from Tuple4-collection.
func Unzip4[T1 any, T2 any, T3 any, T4 any](collection []Tuple4[T1, T2, T3, T4]) ([]T1, []T2, []T3, []T4) {
	length := len(collection)
	result1 := make([]T1, length)
	result2 := make([]T2, length)
	result3 := make([]T3, length)
	result4 := make([]T4, length)
	for index := 0; index < length; index++ {
		result1[index] = collection[index].A
		result2[index] = collection[index].B
		result3[index] = collection[index].C
		result4[index] = collection[index].D
	}
	return result1, result2, result3, result4
}

type Tuple5[T1 any, T2 any, T3 any, T4 any, T5 any] struct {
	A T1
	B T2
	C T3
	D T4
	E T5
}

// Pack5 returns a Tuple5 instance.
func Pack5[T1 any, T2 any, T3 any, T4 any, T5 any](a T1, b T2, c T3, d T4, e T5) Tuple5[T1, T2, T3, T4, T5] {
	return Tuple5[T1, T2, T3, T4, T5]{ A: a, B: b, C: c, D: d, E: e }
}

// Unpack5 returns a Tuple5's inner value.
func Unpack5[T1 any, T2 any, T3 any, T4 any, T5 any](t5 Tuple5[T1, T2, T3, T4, T5]) (T1, T2, T3, T4, T5) {
	return t5.A, t5.B, t5.C, t5.D, t5.E
}

// Zip5 returns a Tuple5 slice, whose length is max of input collections.
func Zip5[T1 any, T2 any, T3 any, T4 any, T5 any](collection1 []T1, collection2 []T2, collection3 []T3, collection4 []T4, collection5 []T5) []Tuple5[T1, T2, T3, T4, T5] {
	maxLength := Max(len(collection1), len(collection2), len(collection3), len(collection4), len(collection5))
	result := make([]Tuple5[T1, T2, T3, T4, T5], maxLength)
	for index := 0; index < maxLength; index++ {
		a, _ := Nth(collection1, index)
		b, _ := Nth(collection2, index)
		c, _ := Nth(collection3, index)
		d, _ := Nth(collection4, index)
		e, _ := Nth(collection5, index)
		result[index] = Tuple5[T1, T2, T3, T4, T5]{ A: a, B: b, C: c, D: d, E: e }
	}
	return result
}

// Unzip5 returns 5 slices, whose elements come from Tuple5-collection.
func Unzip5[T1 any, T2 any, T3 any, T4 any, T5 any](collection []Tuple5[T1, T2, T3, T4, T5]) ([]T1, []T2, []T3, []T4, []T5) {
	length := len(collection)
	result1 := make([]T1, length)
	result2 := make([]T2, length)
	result3 := make([]T3, length)
	result4 := make([]T4, length)
	result5 := make([]T5, length)
	for index := 0; index < length; index++ {
		result1[index] = collection[index].A
		result2[index] = collection[index].B
		result3[index] = collection[index].C
		result4[index] = collection[index].D
		result5[index] = collection[index].E
	}
	return result1, result2, result3, result4, result5
}

type Tuple6[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any] struct {
	A T1
	B T2
	C T3
	D T4
	E T5
	F T6
}

// Pack6 returns a Tuple6 instance.
func Pack6[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any](a T1, b T2, c T3, d T4, e T5, f T6) Tuple6[T1, T2, T3, T4, T5, T6] {
	return Tuple6[T1, T2, T3, T4, T5, T6]{ A: a, B: b, C: c, D: d, E: e, F: f }
}

// Unpack6 returns a Tuple6's inner value.
func Unpack6[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any](t6 Tuple6[T1, T2, T3, T4, T5, T6]) (T1, T2, T3, T4, T5, T6) {
	return t6.A, t6.B, t6.C, t6.D, t6.E, t6.F
}

// Zip6 returns a Tuple6 slice, whose length is max of input collections.
func Zip6[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any](collection1 []T1, collection2 []T2, collection3 []T3, collection4 []T4, collection5 []T5, collection6 []T6) []Tuple6[T1, T2, T3, T4, T5, T6] {
	maxLength := Max(len(collection1), len(collection2), len(collection3), len(collection4), len(collection5), len(collection6))
	result := make([]Tuple6[T1, T2, T3, T4, T5, T6], maxLength)
	for index := 0; index < maxLength; index++ {
		a, _ := Nth(collection1, index)
		b, _ := Nth(collection2, index)
		c, _ := Nth(collection3, index)
		d, _ := Nth(collection4, index)
		e, _ := Nth(collection5, index)
		f, _ := Nth(collection6, index)
		result[index] = Tuple6[T1, T2, T3, T4, T5, T6]{ A: a, B: b, C: c, D: d, E: e, F: f }
	}
	return result
}

// Unzip6 returns 6 slices, whose elements come from Tuple6-collection.
func Unzip6[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any](collection []Tuple6[T1, T2, T3, T4, T5, T6]) ([]T1, []T2, []T3, []T4, []T5, []T6) {
	length := len(collection)
	result1 := make([]T1, length)
	result2 := make([]T2, length)
	result3 := make([]T3, length)
	result4 := make([]T4, length)
	result5 := make([]T5, length)
	result6 := make([]T6, length)
	for index := 0; index < length; index++ {
		result1[index] = collection[index].A
		result2[index] = collection[index].B
		result3[index] = collection[index].C
		result4[index] = collection[index].D
		result5[index] = collection[index].E
		result6[index] = collection[index].F
	}
	return result1, result2, result3, result4, result5, result6
}

type Tuple7[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any] struct {
	A T1
	B T2
	C T3
	D T4
	E T5
	F T6
	G T7
}

// Pack7 returns a Tuple7 instance.
func Pack7[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any](a T1, b T2, c T3, d T4, e T5, f T6, g T7) Tuple7[T1, T2, T3, T4, T5, T6, T7] {
	return Tuple7[T1, T2, T3, T4, T5, T6, T7]{ A: a, B: b, C: c, D: d, E: e, F: f, G: g }
}

// Unpack7 returns a Tuple7's inner value.
func Unpack7[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any](t7 Tuple7[T1, T2, T3, T4, T5, T6, T7]) (T1, T2, T3, T4, T5, T6, T7) {
	return t7.A, t7.B, t7.C, t7.D, t7.E, t7.F, t7.G
}

// Zip7 returns a Tuple7 slice, whose length is max of input collections.
func Zip7[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any](collection1 []T1, collection2 []T2, collection3 []T3, collection4 []T4, collection5 []T5, collection6 []T6, collection7 []T7) []Tuple7[T1, T2, T3, T4, T5, T6, T7] {
	maxLength := Max(len(collection1), len(collection2), len(collection3), len(collection4), len(collection5), len(collection6), len(collection7))
	result := make([]Tuple7[T1, T2, T3, T4, T5, T6, T7], maxLength)
	for index := 0; index < maxLength; index++ {
		a, _ := Nth(collection1, index)
		b, _ := Nth(collection2, index)
		c, _ := Nth(collection3, index)
		d, _ := Nth(collection4, index)
		e, _ := Nth(collection5, index)
		f, _ := Nth(collection6, index)
		g, _ := Nth(collection7, index)
		result[index] = Tuple7[T1, T2, T3, T4, T5, T6, T7]{ A: a, B: b, C: c, D: d, E: e, F: f, G: g }
	}
	return result
}

// Unzip7 returns 7 slices, whose elements come from Tuple7-collection.
func Unzip7[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any](collection []Tuple7[T1, T2, T3, T4, T5, T6, T7]) ([]T1, []T2, []T3, []T4, []T5, []T6, []T7) {
	length := len(collection)
	result1 := make([]T1, length)
	result2 := make([]T2, length)
	result3 := make([]T3, length)
	result4 := make([]T4, length)
	result5 := make([]T5, length)
	result6 := make([]T6, length)
	result7 := make([]T7, length)
	for index := 0; index < length; index++ {
		result1[index] = collection[index].A
		result2[index] = collection[index].B
		result3[index] = collection[index].C
		result4[index] = collection[index].D
		result5[index] = collection[index].E
		result6[index] = collection[index].F
		result7[index] = collection[index].G
	}
	return result1, result2, result3, result4, result5, result6, result7
}

type Tuple8[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any] struct {
	A T1
	B T2
	C T3
	D T4
	E T5
	F T6
	G T7
	H T8
}

// Pack8 returns a Tuple8 instance.
func Pack8[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any](a T1, b T2, c T3, d T4, e T5, f T6, g T7, h T8) Tuple8[T1, T2, T3, T4, T5, T6, T7, T8] {
	return Tuple8[T1, T2, T3, T4, T5, T6, T7, T8]{ A: a, B: b, C: c, D: d, E: e, F: f, G: g, H: h }
}

// Unpack8 returns a Tuple8's inner value.
func Unpack8[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any](t8 Tuple8[T1, T2, T3, T4, T5, T6, T7, T8]) (T1, T2, T3, T4, T5, T6, T7, T8) {
	return t8.A, t8.B, t8.C, t8.D, t8.E, t8.F, t8.G, t8.H
}

// Zip8 returns a Tuple8 slice, whose length is max of input collections.
func Zip8[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any](collection1 []T1, collection2 []T2, collection3 []T3, collection4 []T4, collection5 []T5, collection6 []T6, collection7 []T7, collection8 []T8) []Tuple8[T1, T2, T3, T4, T5, T6, T7, T8] {
	maxLength := Max(len(collection1), len(collection2), len(collection3), len(collection4), len(collection5), len(collection6), len(collection7), len(collection8))
	result := make([]Tuple8[T1, T2, T3, T4, T5, T6, T7, T8], maxLength)
	for index := 0; index < maxLength; index++ {
		a, _ := Nth(collection1, index)
		b, _ := Nth(collection2, index)
		c, _ := Nth(collection3, index)
		d, _ := Nth(collection4, index)
		e, _ := Nth(collection5, index)
		f, _ := Nth(collection6, index)
		g, _ := Nth(collection7, index)
		h, _ := Nth(collection8, index)
		result[index] = Tuple8[T1, T2, T3, T4, T5, T6, T7, T8]{ A: a, B: b, C: c, D: d, E: e, F: f, G: g, H: h }
	}
	return result
}

// Unzip8 returns 8 slices, whose elements come from Tuple8-collection.
func Unzip8[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any](collection []Tuple8[T1, T2, T3, T4, T5, T6, T7, T8]) ([]T1, []T2, []T3, []T4, []T5, []T6, []T7, []T8) {
	length := len(collection)
	result1 := make([]T1, length)
	result2 := make([]T2, length)
	result3 := make([]T3, length)
	result4 := make([]T4, length)
	result5 := make([]T5, length)
	result6 := make([]T6, length)
	result7 := make([]T7, length)
	result8 := make([]T8, length)
	for index := 0; index < length; index++ {
		result1[index] = collection[index].A
		result2[index] = collection[index].B
		result3[index] = collection[index].C
		result4[index] = collection[index].D
		result5[index] = collection[index].E
		result6[index] = collection[index].F
		result7[index] = collection[index].G
		result8[index] = collection[index].H
	}
	return result1, result2, result3, result4, result5, result6, result7, result8
}

type Tuple9[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any] struct {
	A T1
	B T2
	C T3
	D T4
	E T5
	F T6
	G T7
	H T8
	I T9
}

// Pack9 returns a Tuple9 instance.
func Pack9[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any](a T1, b T2, c T3, d T4, e T5, f T6, g T7, h T8, i T9) Tuple9[T1, T2, T3, T4, T5, T6, T7, T8, T9] {
	return Tuple9[T1, T2, T3, T4, T5, T6, T7, T8, T9]{ A: a, B: b, C: c, D: d, E: e, F: f, G: g, H: h, I: i }
}

// Unpack9 returns a Tuple9's inner value.
func Unpack9[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any](t9 Tuple9[T1, T2, T3, T4, T5, T6, T7, T8, T9]) (T1, T2, T3, T4, T5, T6, T7, T8, T9) {
	return t9.A, t9.B, t9.C, t9.D, t9.E, t9.F, t9.G, t9.H, t9.I
}

// Zip9 returns a Tuple9 slice, whose length is max of input collections.
func Zip9[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any](collection1 []T1, collection2 []T2, collection3 []T3, collection4 []T4, collection5 []T5, collection6 []T6, collection7 []T7, collection8 []T8, collection9 []T9) []Tuple9[T1, T2, T3, T4, T5, T6, T7, T8, T9] {
	maxLength := Max(len(collection1), len(collection2), len(collection3), len(collection4), len(collection5), len(collection6), len(collection7), len(collection8), len(collection9))
	result := make([]Tuple9[T1, T2, T3, T4, T5, T6, T7, T8, T9], maxLength)
	for index := 0; index < maxLength; index++ {
		a, _ := Nth(collection1, index)
		b, _ := Nth(collection2, index)
		c, _ := Nth(collection3, index)
		d, _ := Nth(collection4, index)
		e, _ := Nth(collection5, index)
		f, _ := Nth(collection6, index)
		g, _ := Nth(collection7, index)
		h, _ := Nth(collection8, index)
		i, _ := Nth(collection9, index)
		result[index] = Tuple9[T1, T2, T3, T4, T5, T6, T7, T8, T9]{ A: a, B: b, C: c, D: d, E: e, F: f, G: g, H: h, I: i }
	}
	return result
}

// Unzip9 returns 9 slices, whose elements come from Tuple9-collection.
func Unzip9[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any](collection []Tuple9[T1, T2, T3, T4, T5, T6, T7, T8, T9]) ([]T1, []T2, []T3, []T4, []T5, []T6, []T7, []T8, []T9) {
	length := len(collection)
	result1 := make([]T1, length)
	result2 := make([]T2, length)
	result3 := make([]T3, length)
	result4 := make([]T4, length)
	result5 := make([]T5, length)
	result6 := make([]T6, length)
	result7 := make([]T7, length)
	result8 := make([]T8, length)
	result9 := make([]T9, length)
	for index := 0; index < length; index++ {
		result1[index] = collection[index].A
		result2[index] = collection[index].B
		result3[index] = collection[index].C
		result4[index] = collection[index].D
		result5[index] = collection[index].E
		result6[index] = collection[index].F
		result7[index] = collection[index].G
		result8[index] = collection[index].H
		result9[index] = collection[index].I
	}
	return result1, result2, result3, result4, result5, result6, result7, result8, result9
}

type Tuple10[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any] struct {
	A T1
	B T2
	C T3
	D T4
	E T5
	F T6
	G T7
	H T8
	I T9
	J T10
}

// Pack10 returns a Tuple10 instance.
func Pack10[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any](a T1, b T2, c T3, d T4, e T5, f T6, g T7, h T8, i T9, j T10) Tuple10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10] {
	return Tuple10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]{ A: a, B: b, C: c, D: d, E: e, F: f, G: g, H: h, I: i, J: j }
}

// Unpack10 returns a Tuple10's inner value.
func Unpack10[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any](t10 Tuple10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]) (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) {
	return t10.A, t10.B, t10.C, t10.D, t10.E, t10.F, t10.G, t10.H, t10.I, t10.J
}

// Zip10 returns a Tuple10 slice, whose length is max of input collections.
func Zip10[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any](collection1 []T1, collection2 []T2, collection3 []T3, collection4 []T4, collection5 []T5, collection6 []T6, collection7 []T7, collection8 []T8, collection9 []T9, collection10 []T10) []Tuple10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10] {
	maxLength := Max(len(collection1), len(collection2), len(collection3), len(collection4), len(collection5), len(collection6), len(collection7), len(collection8), len(collection9), len(collection10))
	result := make([]Tuple10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10], maxLength)
	for index := 0; index < maxLength; index++ {
		a, _ := Nth(collection1, index)
		b, _ := Nth(collection2, index)
		c, _ := Nth(collection3, index)
		d, _ := Nth(collection4, index)
		e, _ := Nth(collection5, index)
		f, _ := Nth(collection6, index)
		g, _ := Nth(collection7, index)
		h, _ := Nth(collection8, index)
		i, _ := Nth(collection9, index)
		j, _ := Nth(collection10, index)
		result[index] = Tuple10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]{ A: a, B: b, C: c, D: d, E: e, F: f, G: g, H: h, I: i, J: j }
	}
	return result
}

// Unzip10 returns 10 slices, whose elements come from Tuple10-collection.
func Unzip10[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any](collection []Tuple10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]) ([]T1, []T2, []T3, []T4, []T5, []T6, []T7, []T8, []T9, []T10) {
	length := len(collection)
	result1 := make([]T1, length)
	result2 := make([]T2, length)
	result3 := make([]T3, length)
	result4 := make([]T4, length)
	result5 := make([]T5, length)
	result6 := make([]T6, length)
	result7 := make([]T7, length)
	result8 := make([]T8, length)
	result9 := make([]T9, length)
	result10 := make([]T10, length)
	for index := 0; index < length; index++ {
		result1[index] = collection[index].A
		result2[index] = collection[index].B
		result3[index] = collection[index].C
		result4[index] = collection[index].D
		result5[index] = collection[index].E
		result6[index] = collection[index].F
		result7[index] = collection[index].G
		result8[index] = collection[index].H
		result9[index] = collection[index].I
		result10[index] = collection[index].J
	}
	return result1, result2, result3, result4, result5, result6, result7, result8, result9, result10
}

type Tuple11[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any] struct {
	A T1
	B T2
	C T3
	D T4
	E T5
	F T6
	G T7
	H T8
	I T9
	J T10
	K T11
}

// Pack11 returns a Tuple11 instance.
func Pack11[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any](a T1, b T2, c T3, d T4, e T5, f T6, g T7, h T8, i T9, j T10, k T11) Tuple11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11] {
	return Tuple11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11]{ A: a, B: b, C: c, D: d, E: e, F: f, G: g, H: h, I: i, J: j, K: k }
}

// Unpack11 returns a Tuple11's inner value.
func Unpack11[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any](t11 Tuple11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11]) (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) {
	return t11.A, t11.B, t11.C, t11.D, t11.E, t11.F, t11.G, t11.H, t11.I, t11.J, t11.K
}

// Zip11 returns a Tuple11 slice, whose length is max of input collections.
func Zip11[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any](collection1 []T1, collection2 []T2, collection3 []T3, collection4 []T4, collection5 []T5, collection6 []T6, collection7 []T7, collection8 []T8, collection9 []T9, collection10 []T10, collection11 []T11) []Tuple11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11] {
	maxLength := Max(len(collection1), len(collection2), len(collection3), len(collection4), len(collection5), len(collection6), len(collection7), len(collection8), len(collection9), len(collection10), len(collection11))
	result := make([]Tuple11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11], maxLength)
	for index := 0; index < maxLength; index++ {
		a, _ := Nth(collection1, index)
		b, _ := Nth(collection2, index)
		c, _ := Nth(collection3, index)
		d, _ := Nth(collection4, index)
		e, _ := Nth(collection5, index)
		f, _ := Nth(collection6, index)
		g, _ := Nth(collection7, index)
		h, _ := Nth(collection8, index)
		i, _ := Nth(collection9, index)
		j, _ := Nth(collection10, index)
		k, _ := Nth(collection11, index)
		result[index] = Tuple11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11]{ A: a, B: b, C: c, D: d, E: e, F: f, G: g, H: h, I: i, J: j, K: k }
	}
	return result
}

// Unzip11 returns 11 slices, whose elements come from Tuple11-collection.
func Unzip11[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any](collection []Tuple11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11]) ([]T1, []T2, []T3, []T4, []T5, []T6, []T7, []T8, []T9, []T10, []T11) {
	length := len(collection)
	result1 := make([]T1, length)
	result2 := make([]T2, length)
	result3 := make([]T3, length)
	result4 := make([]T4, length)
	result5 := make([]T5, length)
	result6 := make([]T6, length)
	result7 := make([]T7, length)
	result8 := make([]T8, length)
	result9 := make([]T9, length)
	result10 := make([]T10, length)
	result11 := make([]T11, length)
	for index := 0; index < length; index++ {
		result1[index] = collection[index].A
		result2[index] = collection[index].B
		result3[index] = collection[index].C
		result4[index] = collection[index].D
		result5[index] = collection[index].E
		result6[index] = collection[index].F
		result7[index] = collection[index].G
		result8[index] = collection[index].H
		result9[index] = collection[index].I
		result10[index] = collection[index].J
		result11[index] = collection[index].K
	}
	return result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11
}

type Tuple12[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any] struct {
	A T1
	B T2
	C T3
	D T4
	E T5
	F T6
	G T7
	H T8
	I T9
	J T10
	K T11
	L T12
}

// Pack12 returns a Tuple12 instance.
func Pack12[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any](a T1, b T2, c T3, d T4, e T5, f T6, g T7, h T8, i T9, j T10, k T11, l T12) Tuple12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12] {
	return Tuple12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12]{ A: a, B: b, C: c, D: d, E: e, F: f, G: g, H: h, I: i, J: j, K: k, L: l }
}

// Unpack12 returns a Tuple12's inner value.
func Unpack12[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any](t12 Tuple12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12]) (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) {
	return t12.A, t12.B, t12.C, t12.D, t12.E, t12.F, t12.G, t12.H, t12.I, t12.J, t12.K, t12.L
}

// Zip12 returns a Tuple12 slice, whose length is max of input collections.
func Zip12[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any](collection1 []T1, collection2 []T2, collection3 []T3, collection4 []T4, collection5 []T5, collection6 []T6, collection7 []T7, collection8 []T8, collection9 []T9, collection10 []T10, collection11 []T11, collection12 []T12) []Tuple12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12] {
	maxLength := Max(len(collection1), len(collection2), len(collection3), len(collection4), len(collection5), len(collection6), len(collection7), len(collection8), len(collection9), len(collection10), len(collection11), len(collection12))
	result := make([]Tuple12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12], maxLength)
	for index := 0; index < maxLength; index++ {
		a, _ := Nth(collection1, index)
		b, _ := Nth(collection2, index)
		c, _ := Nth(collection3, index)
		d, _ := Nth(collection4, index)
		e, _ := Nth(collection5, index)
		f, _ := Nth(collection6, index)
		g, _ := Nth(collection7, index)
		h, _ := Nth(collection8, index)
		i, _ := Nth(collection9, index)
		j, _ := Nth(collection10, index)
		k, _ := Nth(collection11, index)
		l, _ := Nth(collection12, index)
		result[index] = Tuple12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12]{ A: a, B: b, C: c, D: d, E: e, F: f, G: g, H: h, I: i, J: j, K: k, L: l }
	}
	return result
}

// Unzip12 returns 12 slices, whose elements come from Tuple12-collection.
func Unzip12[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any](collection []Tuple12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12]) ([]T1, []T2, []T3, []T4, []T5, []T6, []T7, []T8, []T9, []T10, []T11, []T12) {
	length := len(collection)
	result1 := make([]T1, length)
	result2 := make([]T2, length)
	result3 := make([]T3, length)
	result4 := make([]T4, length)
	result5 := make([]T5, length)
	result6 := make([]T6, length)
	result7 := make([]T7, length)
	result8 := make([]T8, length)
	result9 := make([]T9, length)
	result10 := make([]T10, length)
	result11 := make([]T11, length)
	result12 := make([]T12, length)
	for index := 0; index < length; index++ {
		result1[index] = collection[index].A
		result2[index] = collection[index].B
		result3[index] = collection[index].C
		result4[index] = collection[index].D
		result5[index] = collection[index].E
		result6[index] = collection[index].F
		result7[index] = collection[index].G
		result8[index] = collection[index].H
		result9[index] = collection[index].I
		result10[index] = collection[index].J
		result11[index] = collection[index].K
		result12[index] = collection[index].L
	}
	return result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11, result12
}

type Tuple13[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any] struct {
	A T1
	B T2
	C T3
	D T4
	E T5
	F T6
	G T7
	H T8
	I T9
	J T10
	K T11
	L T12
	M T13
}

// Pack13 returns a Tuple13 instance.
func Pack13[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any](a T1, b T2, c T3, d T4, e T5, f T6, g T7, h T8, i T9, j T10, k T11, l T12, m T13) Tuple13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13] {
	return Tuple13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13]{ A: a, B: b, C: c, D: d, E: e, F: f, G: g, H: h, I: i, J: j, K: k, L: l, M: m }
}

// Unpack13 returns a Tuple13's inner value.
func Unpack13[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any](t13 Tuple13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13]) (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) {
	return t13.A, t13.B, t13.C, t13.D, t13.E, t13.F, t13.G, t13.H, t13.I, t13.J, t13.K, t13.L, t13.M
}

// Zip13 returns a Tuple13 slice, whose length is max of input collections.
func Zip13[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any](collection1 []T1, collection2 []T2, collection3 []T3, collection4 []T4, collection5 []T5, collection6 []T6, collection7 []T7, collection8 []T8, collection9 []T9, collection10 []T10, collection11 []T11, collection12 []T12, collection13 []T13) []Tuple13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13] {
	maxLength := Max(len(collection1), len(collection2), len(collection3), len(collection4), len(collection5), len(collection6), len(collection7), len(collection8), len(collection9), len(collection10), len(collection11), len(collection12), len(collection13))
	result := make([]Tuple13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13], maxLength)
	for index := 0; index < maxLength; index++ {
		a, _ := Nth(collection1, index)
		b, _ := Nth(collection2, index)
		c, _ := Nth(collection3, index)
		d, _ := Nth(collection4, index)
		e, _ := Nth(collection5, index)
		f, _ := Nth(collection6, index)
		g, _ := Nth(collection7, index)
		h, _ := Nth(collection8, index)
		i, _ := Nth(collection9, index)
		j, _ := Nth(collection10, index)
		k, _ := Nth(collection11, index)
		l, _ := Nth(collection12, index)
		m, _ := Nth(collection13, index)
		result[index] = Tuple13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13]{ A: a, B: b, C: c, D: d, E: e, F: f, G: g, H: h, I: i, J: j, K: k, L: l, M: m }
	}
	return result
}

// Unzip13 returns 13 slices, whose elements come from Tuple13-collection.
func Unzip13[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any](collection []Tuple13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13]) ([]T1, []T2, []T3, []T4, []T5, []T6, []T7, []T8, []T9, []T10, []T11, []T12, []T13) {
	length := len(collection)
	result1 := make([]T1, length)
	result2 := make([]T2, length)
	result3 := make([]T3, length)
	result4 := make([]T4, length)
	result5 := make([]T5, length)
	result6 := make([]T6, length)
	result7 := make([]T7, length)
	result8 := make([]T8, length)
	result9 := make([]T9, length)
	result10 := make([]T10, length)
	result11 := make([]T11, length)
	result12 := make([]T12, length)
	result13 := make([]T13, length)
	for index := 0; index < length; index++ {
		result1[index] = collection[index].A
		result2[index] = collection[index].B
		result3[index] = collection[index].C
		result4[index] = collection[index].D
		result5[index] = collection[index].E
		result6[index] = collection[index].F
		result7[index] = collection[index].G
		result8[index] = collection[index].H
		result9[index] = collection[index].I
		result10[index] = collection[index].J
		result11[index] = collection[index].K
		result12[index] = collection[index].L
		result13[index] = collection[index].M
	}
	return result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11, result12, result13
}

type Tuple14[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any] struct {
	A T1
	B T2
	C T3
	D T4
	E T5
	F T6
	G T7
	H T8
	I T9
	J T10
	K T11
	L T12
	M T13
	N T14
}

// Pack14 returns a Tuple14 instance.
func Pack14[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any](a T1, b T2, c T3, d T4, e T5, f T6, g T7, h T8, i T9, j T10, k T11, l T12, m T13, n T14) Tuple14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14] {
	return Tuple14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14]{ A: a, B: b, C: c, D: d, E: e, F: f, G: g, H: h, I: i, J: j, K: k, L: l, M: m, N: n }
}

// Unpack14 returns a Tuple14's inner value.
func Unpack14[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any](t14 Tuple14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14]) (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) {
	return t14.A, t14.B, t14.C, t14.D, t14.E, t14.F, t14.G, t14.H, t14.I, t14.J, t14.K, t14.L, t14.M, t14.N
}

// Zip14 returns a Tuple14 slice, whose length is max of input collections.
func Zip14[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any](collection1 []T1, collection2 []T2, collection3 []T3, collection4 []T4, collection5 []T5, collection6 []T6, collection7 []T7, collection8 []T8, collection9 []T9, collection10 []T10, collection11 []T11, collection12 []T12, collection13 []T13, collection14 []T14) []Tuple14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14] {
	maxLength := Max(len(collection1), len(collection2), len(collection3), len(collection4), len(collection5), len(collection6), len(collection7), len(collection8), len(collection9), len(collection10), len(collection11), len(collection12), len(collection13), len(collection14))
	result := make([]Tuple14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14], maxLength)
	for index := 0; index < maxLength; index++ {
		a, _ := Nth(collection1, index)
		b, _ := Nth(collection2, index)
		c, _ := Nth(collection3, index)
		d, _ := Nth(collection4, index)
		e, _ := Nth(collection5, index)
		f, _ := Nth(collection6, index)
		g, _ := Nth(collection7, index)
		h, _ := Nth(collection8, index)
		i, _ := Nth(collection9, index)
		j, _ := Nth(collection10, index)
		k, _ := Nth(collection11, index)
		l, _ := Nth(collection12, index)
		m, _ := Nth(collection13, index)
		n, _ := Nth(collection14, index)
		result[index] = Tuple14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14]{ A: a, B: b, C: c, D: d, E: e, F: f, G: g, H: h, I: i, J: j, K: k, L: l, M: m, N: n }
	}
	return result
}

// Unzip14 returns 14 slices, whose elements come from Tuple14-collection.
func Unzip14[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any](collection []Tuple14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14]) ([]T1, []T2, []T3, []T4, []T5, []T6, []T7, []T8, []T9, []T10, []T11, []T12, []T13, []T14) {
	length := len(collection)
	result1 := make([]T1, length)
	result2 := make([]T2, length)
	result3 := make([]T3, length)
	result4 := make([]T4, length)
	result5 := make([]T5, length)
	result6 := make([]T6, length)
	result7 := make([]T7, length)
	result8 := make([]T8, length)
	result9 := make([]T9, length)
	result10 := make([]T10, length)
	result11 := make([]T11, length)
	result12 := make([]T12, length)
	result13 := make([]T13, length)
	result14 := make([]T14, length)
	for index := 0; index < length; index++ {
		result1[index] = collection[index].A
		result2[index] = collection[index].B
		result3[index] = collection[index].C
		result4[index] = collection[index].D
		result5[index] = collection[index].E
		result6[index] = collection[index].F
		result7[index] = collection[index].G
		result8[index] = collection[index].H
		result9[index] = collection[index].I
		result10[index] = collection[index].J
		result11[index] = collection[index].K
		result12[index] = collection[index].L
		result13[index] = collection[index].M
		result14[index] = collection[index].N
	}
	return result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11, result12, result13, result14
}

type Tuple15[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any] struct {
	A T1
	B T2
	C T3
	D T4
	E T5
	F T6
	G T7
	H T8
	I T9
	J T10
	K T11
	L T12
	M T13
	N T14
	O T15
}

// Pack15 returns a Tuple15 instance.
func Pack15[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any](a T1, b T2, c T3, d T4, e T5, f T6, g T7, h T8, i T9, j T10, k T11, l T12, m T13, n T14, o T15) Tuple15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15] {
	return Tuple15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15]{ A: a, B: b, C: c, D: d, E: e, F: f, G: g, H: h, I: i, J: j, K: k, L: l, M: m, N: n, O: o }
}

// Unpack15 returns a Tuple15's inner value.
func Unpack15[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any](t15 Tuple15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15]) (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) {
	return t15.A, t15.B, t15.C, t15.D, t15.E, t15.F, t15.G, t15.H, t15.I, t15.J, t15.K, t15.L, t15.M, t15.N, t15.O
}

// Zip15 returns a Tuple15 slice, whose length is max of input collections.
func Zip15[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any](collection1 []T1, collection2 []T2, collection3 []T3, collection4 []T4, collection5 []T5, collection6 []T6, collection7 []T7, collection8 []T8, collection9 []T9, collection10 []T10, collection11 []T11, collection12 []T12, collection13 []T13, collection14 []T14, collection15 []T15) []Tuple15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15] {
	maxLength := Max(len(collection1), len(collection2), len(collection3), len(collection4), len(collection5), len(collection6), len(collection7), len(collection8), len(collection9), len(collection10), len(collection11), len(collection12), len(collection13), len(collection14), len(collection15))
	result := make([]Tuple15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15], maxLength)
	for index := 0; index < maxLength; index++ {
		a, _ := Nth(collection1, index)
		b, _ := Nth(collection2, index)
		c, _ := Nth(collection3, index)
		d, _ := Nth(collection4, index)
		e, _ := Nth(collection5, index)
		f, _ := Nth(collection6, index)
		g, _ := Nth(collection7, index)
		h, _ := Nth(collection8, index)
		i, _ := Nth(collection9, index)
		j, _ := Nth(collection10, index)
		k, _ := Nth(collection11, index)
		l, _ := Nth(collection12, index)
		m, _ := Nth(collection13, index)
		n, _ := Nth(collection14, index)
		o, _ := Nth(collection15, index)
		result[index] = Tuple15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15]{ A: a, B: b, C: c, D: d, E: e, F: f, G: g, H: h, I: i, J: j, K: k, L: l, M: m, N: n, O: o }
	}
	return result
}

// Unzip15 returns 15 slices, whose elements come from Tuple15-collection.
func Unzip15[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any](collection []Tuple15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15]) ([]T1, []T2, []T3, []T4, []T5, []T6, []T7, []T8, []T9, []T10, []T11, []T12, []T13, []T14, []T15) {
	length := len(collection)
	result1 := make([]T1, length)
	result2 := make([]T2, length)
	result3 := make([]T3, length)
	result4 := make([]T4, length)
	result5 := make([]T5, length)
	result6 := make([]T6, length)
	result7 := make([]T7, length)
	result8 := make([]T8, length)
	result9 := make([]T9, length)
	result10 := make([]T10, length)
	result11 := make([]T11, length)
	result12 := make([]T12, length)
	result13 := make([]T13, length)
	result14 := make([]T14, length)
	result15 := make([]T15, length)
	for index := 0; index < length; index++ {
		result1[index] = collection[index].A
		result2[index] = collection[index].B
		result3[index] = collection[index].C
		result4[index] = collection[index].D
		result5[index] = collection[index].E
		result6[index] = collection[index].F
		result7[index] = collection[index].G
		result8[index] = collection[index].H
		result9[index] = collection[index].I
		result10[index] = collection[index].J
		result11[index] = collection[index].K
		result12[index] = collection[index].L
		result13[index] = collection[index].M
		result14[index] = collection[index].N
		result15[index] = collection[index].O
	}
	return result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11, result12, result13, result14, result15
}

type Tuple16[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any, T16 any] struct {
	A T1
	B T2
	C T3
	D T4
	E T5
	F T6
	G T7
	H T8
	I T9
	J T10
	K T11
	L T12
	M T13
	N T14
	O T15
	P T16
}

// Pack16 returns a Tuple16 instance.
func Pack16[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any, T16 any](a T1, b T2, c T3, d T4, e T5, f T6, g T7, h T8, i T9, j T10, k T11, l T12, m T13, n T14, o T15, p T16) Tuple16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16] {
	return Tuple16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16]{ A: a, B: b, C: c, D: d, E: e, F: f, G: g, H: h, I: i, J: j, K: k, L: l, M: m, N: n, O: o, P: p }
}

// Unpack16 returns a Tuple16's inner value.
func Unpack16[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any, T16 any](t16 Tuple16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16]) (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) {
	return t16.A, t16.B, t16.C, t16.D, t16.E, t16.F, t16.G, t16.H, t16.I, t16.J, t16.K, t16.L, t16.M, t16.N, t16.O, t16.P
}

// Zip16 returns a Tuple16 slice, whose length is max of input collections.
func Zip16[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any, T16 any](collection1 []T1, collection2 []T2, collection3 []T3, collection4 []T4, collection5 []T5, collection6 []T6, collection7 []T7, collection8 []T8, collection9 []T9, collection10 []T10, collection11 []T11, collection12 []T12, collection13 []T13, collection14 []T14, collection15 []T15, collection16 []T16) []Tuple16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16] {
	maxLength := Max(len(collection1), len(collection2), len(collection3), len(collection4), len(collection5), len(collection6), len(collection7), len(collection8), len(collection9), len(collection10), len(collection11), len(collection12), len(collection13), len(collection14), len(collection15), len(collection16))
	result := make([]Tuple16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16], maxLength)
	for index := 0; index < maxLength; index++ {
		a, _ := Nth(collection1, index)
		b, _ := Nth(collection2, index)
		c, _ := Nth(collection3, index)
		d, _ := Nth(collection4, index)
		e, _ := Nth(collection5, index)
		f, _ := Nth(collection6, index)
		g, _ := Nth(collection7, index)
		h, _ := Nth(collection8, index)
		i, _ := Nth(collection9, index)
		j, _ := Nth(collection10, index)
		k, _ := Nth(collection11, index)
		l, _ := Nth(collection12, index)
		m, _ := Nth(collection13, index)
		n, _ := Nth(collection14, index)
		o, _ := Nth(collection15, index)
		p, _ := Nth(collection16, index)
		result[index] = Tuple16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16]{ A: a, B: b, C: c, D: d, E: e, F: f, G: g, H: h, I: i, J: j, K: k, L: l, M: m, N: n, O: o, P: p }
	}
	return result
}

// Unzip16 returns 16 slices, whose elements come from Tuple16-collection.
func Unzip16[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any, T16 any](collection []Tuple16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16]) ([]T1, []T2, []T3, []T4, []T5, []T6, []T7, []T8, []T9, []T10, []T11, []T12, []T13, []T14, []T15, []T16) {
	length := len(collection)
	result1 := make([]T1, length)
	result2 := make([]T2, length)
	result3 := make([]T3, length)
	result4 := make([]T4, length)
	result5 := make([]T5, length)
	result6 := make([]T6, length)
	result7 := make([]T7, length)
	result8 := make([]T8, length)
	result9 := make([]T9, length)
	result10 := make([]T10, length)
	result11 := make([]T11, length)
	result12 := make([]T12, length)
	result13 := make([]T13, length)
	result14 := make([]T14, length)
	result15 := make([]T15, length)
	result16 := make([]T16, length)
	for index := 0; index < length; index++ {
		result1[index] = collection[index].A
		result2[index] = collection[index].B
		result3[index] = collection[index].C
		result4[index] = collection[index].D
		result5[index] = collection[index].E
		result6[index] = collection[index].F
		result7[index] = collection[index].G
		result8[index] = collection[index].H
		result9[index] = collection[index].I
		result10[index] = collection[index].J
		result11[index] = collection[index].K
		result12[index] = collection[index].L
		result13[index] = collection[index].M
		result14[index] = collection[index].N
		result15[index] = collection[index].O
		result16[index] = collection[index].P
	}
	return result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11, result12, result13, result14, result15, result16
}

type Tuple17[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any, T16 any, T17 any] struct {
	A T1
	B T2
	C T3
	D T4
	E T5
	F T6
	G T7
	H T8
	I T9
	J T10
	K T11
	L T12
	M T13
	N T14
	O T15
	P T16
	Q T17
}

// Pack17 returns a Tuple17 instance.
func Pack17[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any, T16 any, T17 any](a T1, b T2, c T3, d T4, e T5, f T6, g T7, h T8, i T9, j T10, k T11, l T12, m T13, n T14, o T15, p T16, q T17) Tuple17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17] {
	return Tuple17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17]{ A: a, B: b, C: c, D: d, E: e, F: f, G: g, H: h, I: i, J: j, K: k, L: l, M: m, N: n, O: o, P: p, Q: q }
}

// Unpack17 returns a Tuple17's inner value.
func Unpack17[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any, T16 any, T17 any](t17 Tuple17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17]) (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17) {
	return t17.A, t17.B, t17.C, t17.D, t17.E, t17.F, t17.G, t17.H, t17.I, t17.J, t17.K, t17.L, t17.M, t17.N, t17.O, t17.P, t17.Q
}

// Zip17 returns a Tuple17 slice, whose length is max of input collections.
func Zip17[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any, T16 any, T17 any](collection1 []T1, collection2 []T2, collection3 []T3, collection4 []T4, collection5 []T5, collection6 []T6, collection7 []T7, collection8 []T8, collection9 []T9, collection10 []T10, collection11 []T11, collection12 []T12, collection13 []T13, collection14 []T14, collection15 []T15, collection16 []T16, collection17 []T17) []Tuple17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17] {
	maxLength := Max(len(collection1), len(collection2), len(collection3), len(collection4), len(collection5), len(collection6), len(collection7), len(collection8), len(collection9), len(collection10), len(collection11), len(collection12), len(collection13), len(collection14), len(collection15), len(collection16), len(collection17))
	result := make([]Tuple17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17], maxLength)
	for index := 0; index < maxLength; index++ {
		a, _ := Nth(collection1, index)
		b, _ := Nth(collection2, index)
		c, _ := Nth(collection3, index)
		d, _ := Nth(collection4, index)
		e, _ := Nth(collection5, index)
		f, _ := Nth(collection6, index)
		g, _ := Nth(collection7, index)
		h, _ := Nth(collection8, index)
		i, _ := Nth(collection9, index)
		j, _ := Nth(collection10, index)
		k, _ := Nth(collection11, index)
		l, _ := Nth(collection12, index)
		m, _ := Nth(collection13, index)
		n, _ := Nth(collection14, index)
		o, _ := Nth(collection15, index)
		p, _ := Nth(collection16, index)
		q, _ := Nth(collection17, index)
		result[index] = Tuple17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17]{ A: a, B: b, C: c, D: d, E: e, F: f, G: g, H: h, I: i, J: j, K: k, L: l, M: m, N: n, O: o, P: p, Q: q }
	}
	return result
}

// Unzip17 returns 17 slices, whose elements come from Tuple17-collection.
func Unzip17[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any, T7 any, T8 any, T9 any, T10 any, T11 any, T12 any, T13 any, T14 any, T15 any, T16 any, T17 any](collection []Tuple17[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17]) ([]T1, []T2, []T3, []T4, []T5, []T6, []T7, []T8, []T9, []T10, []T11, []T12, []T13, []T14, []T15, []T16, []T17) {
	length := len(collection)
	result1 := make([]T1, length)
	result2 := make([]T2, length)
	result3 := make([]T3, length)
	result4 := make([]T4, length)
	result5 := make([]T5, length)
	result6 := make([]T6, length)
	result7 := make([]T7, length)
	result8 := make([]T8, length)
	result9 := make([]T9, length)
	result10 := make([]T10, length)
	result11 := make([]T11, length)
	result12 := make([]T12, length)
	result13 := make([]T13, length)
	result14 := make([]T14, length)
	result15 := make([]T15, length)
	result16 := make([]T16, length)
	result17 := make([]T17, length)
	for index := 0; index < length; index++ {
		result1[index] = collection[index].A
		result2[index] = collection[index].B
		result3[index] = collection[index].C
		result4[index] = collection[index].D
		result5[index] = collection[index].E
		result6[index] = collection[index].F
		result7[index] = collection[index].G
		result8[index] = collection[index].H
		result9[index] = collection[index].I
		result10[index] = collection[index].J
		result11[index] = collection[index].K
		result12[index] = collection[index].L
		result13[index] = collection[index].M
		result14[index] = collection[index].N
		result15[index] = collection[index].O
		result16[index] = collection[index].P
		result17[index] = collection[index].Q
	}
	return result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11, result12, result13, result14, result15, result16, result17
}

