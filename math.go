package toolbox

import "golang.org/x/exp/constraints"

// Range creates a range with abs(elementNum) elements, which starts from 0.
func Range[T constraints.Integer](elementNum int) []T {
	length := Ternary(elementNum >= 0, elementNum, -elementNum)
	step := Ternary(elementNum >= 0, 1, -1)
	result := make([]T, 0, length)
	for i, j := 0, T(0); i < length; i, j = i+1, j+T(step) {
		result = append(result, j)
	}
	return result
}

// RangeFrom creates a range with abs(elementNum) elements, which starts from `from`.
func RangeFrom[T constraints.Integer | constraints.Float](from T, elementNum int) []T {
	length := Ternary(elementNum >= 0, elementNum, -elementNum)
	step := Ternary(elementNum >= 0, 1, -1)
	result := make([]T, 0, length)
	for i, j := 0, from; i < length; i, j = i+1, j+T(step) {
		result = append(result, j)
	}
	return result
}

// RangeWithStep creates a range with abs(elementNum) elements, which starts from `from` and step.
func RangeWithStep[T constraints.Integer | constraints.Float](from, step T, elementNum int) []T {
	result := make([]T, 0, elementNum)
	for i, j := 0, from; i < elementNum; i, j = i+1, j+step {
		result = append(result, j)
	}
	return result
}

// Max return maximum value in elements.
func Max[T constraints.Ordered](elements ...T) T {
	if len(elements) == 0 {
		panic("need at least one elements")
	}
	return Reduce[T, T](elements[1:], func(agg T, item T, index int) T {
		if agg < item {
			agg = item
		}
		return agg
	}, elements[0])
}

// Min return minimum value in elements.
func Min[T constraints.Ordered](elements ...T) T {
	if len(elements) == 0 {
		panic("need at least one elements")
	}
	return Reduce[T, T](elements[1:], func(agg T, item T, index int) T {
		if agg > item {
			agg = item
		}
		return agg
	}, elements[0])
}

// Sum returns sum of collection.
func Sum[T constraints.Integer | constraints.Float | constraints.Complex](collection []T) T {
	return Reduce[T, T](collection, func(agg T, item T, index int) T {
		return agg + item
	}, 0)
}

// SumBy returns sum of items generated by iteratee function.
func SumBy[T any, R constraints.Integer | constraints.Float | constraints.Complex](collection []T, iteratee func(t T, index int) R) R {
	return Reduce[T, R](collection, func(agg R, item T, index int) R {
		return agg + iteratee(item, index)
	}, 0)
}
